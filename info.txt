Ce projet est une application de test d'applications web multi-environnements, conçue pour démontrer les capacités de diverses technologies web.

Le nom de l'application "TestGyver" est un jeu de mots entre "Test" et "MacGyver", suggérant une approche ingénieuse et polyvalente pour la réalisation de tests.

L'application expose les pages et API suivantes :
- / : Page d'authentification
- /dashboard : Tableau de bord principal après authentification
    => Affiche la liste des campagnes
    => Pour les administrateurs, affiche dans le bandeau la possibilite de :
        - Gérer les variables multi-environnements
        - Gérer les utilisateurs
    => Bouton d'ajout de campagne
- /campains/add : Ajout d'une nouvelle campagne
- /campains/:id : Détails d'une campagne spécifique
- /campains/:id/add/test : Ajout d'un test à une campagne
    => Formulaire pour ajouter des actions au test
    => Le formulaire correspond au masque de saisie des actions
- /admin/users : Gestion des utilisateurs (accessible uniquement aux administrateurs)
    - /admin/users/add : Ajout d'un nouvel utilisateur
    - /admin/users/edit/:id : Édition d'un utilisateur existant
- /admin/variables : Gestion des variables (accessible uniquement aux administrateurs)
    => Affiche la liste des variables
    => Bouton d'ajout de variable
    => Trier les variables par environnement
    => Regrouper l'affichage des variables par environnement
    - /admin/variables/add : Ajout d'une nouvelle variable
    - /admin/variables/edit/:id : Édition d'une variable existante
- /api/login : API d'authentification
    => Retourne un token JWT en cas de succès
- /api/logout : API de déconnexion
- /api/users : API de gestion des utilisateurs
    - GET /api/users : Récupère la liste des utilisateurs (admin uniquement)
    - POST /api/users : Crée un nouvel utilisateur (admin uniquement)
    - PUT /api/users/:id : Met à jour un utilisateur existant (admin uniquement)
    - DELETE /api/users/:id : Supprime un utilisateur (admin uniquement)
- /api/campains : API de gestion des campagnes
    - GET /api/campains : Récupère la liste des campagnes
    - POST /api/campains : Crée une nouvelle campagne
    - GET /api/campains/:id : Récupère les détails d'une campagne spécifique
    - PUT /api/campains/:id : Met à jour une campagne existante
    - DELETE /api/campains/:id : Supprime une campagne
- /api/variables : API de gestion des variables (accessible uniquement aux administrateurs)
    - GET /api/variables : Récupère la liste des variables
    - POST /api/variables : Crée une nouvelle variable
    - GET /api/variables/:id : Récupère les détails d'une variable spécifique
    - PUT /api/variables/:id : Met à jour une variable existante
    - DELETE /api/variables/:id : Supprime une variable
- /api/tests : API de gestion des tests
    - GET /api/tests : Récupère la liste des tests
    - POST /api/tests : Crée un nouveau test
    - GET /api/tests/:id : Récupère les détails d'un test spécifique
    - PUT /api/tests/:id : Met à jour un test existant
    - DELETE /api/tests/:id : Supprime un test
- /api/rapports : API de génération et récupération des rapports
    - GET /api/rapports : Récupère la liste des rapports
    - POST /api/rapports : Crée un nouveau rapport
    - GET /api/rapports/:id : Récupère les détails d'un rapport spécifique
    - PUT /api/rapports/:id : Met à jour un rapport existant
    - DELETE /api/rapports/:id : Supprime un rapport
- /swagger : Documentation interactive de l'API

L'application s'appuie sur une base de données mongo et les collections suivantes :
- users
    - _id: ObjectId
    - name: String
    - email: String
    - password: String (hashed)
    - role: String (admin, user)
- variables
    - _id: ObjectId
    - key: String
    - value: Mixed
    - filiere: String
    - description: String
    - isRoot: Boolean (default: false), determine si la variable fait partie du masquage racine
- campains
    - _id: ObjectId
    - userCreated: ObjectId (référence à users)
    - name: String
    - dateCreated: Date
    - description: String
- tests
    - _id: ObjectId
    - campainId: ObjectId (référence à campains)
    - userId: ObjectId (référence à users)
    - dateCreated: Date
    - actions: Array of Objects
        - type: String (spécificité de l'action en fonction des classes d'actions)
        - value: Mixed
- rapports
    - _id: ObjectId
    - campainId: ObjectId (référence à campains)
    - dateCreated: Date
    - result: String (success, failure)
    - details: String
    - filiere: String
    - tests: Array of Objects
        - testId: ObjectId (référence à tests)
        - status: String (passed, failed)
        - logs: String

Les classes d'actions :
- disponible dans le répertoire "plugins/actions"
- chaque classe d'action hérite de la classe de base "ActionBase" qui retourne un code et des traces d'exécution
- chaque action à un masque de saisie spécifique pour les paramètres nécessaires à l'exécution de l'action
    => représenté par un dictionnaire JSON sous la forme :
    {
        "name": "username",
        "type": "string",
        "label": "Nom d'utilisateur",
        "placeholder": "Entrez le nom d'utilisateur",
        "required": true
    }
    => les différents types de champs disponibles sont :
        - string
        - number
        - boolean
        - textarea
        - select (avec une liste d'options)
        - checkbox (case à cocher)
- lors de la saisie d'une champs de type "string" ou "textarea", en fonction du mot en cours de saisie, une liste de tags de variables est proposée à l'utilisateur pour l'insertion
    => si l'utilisateur click sur un tag, celui-ci est inséré dans le champs de saisie par {{variable_key}}
- chaque classe d'action doit implémenter la méthode "execute" qui prend en paramètre un objet de type "ActionContext" qui contient les informations nécessaires à l'exécution de l'action (spécifiques à chaque action )

Les actions disponibles sont :
- HTTPRequestAction : Effectue une requête HTTP (GET, POST, PUT, DELETE) vers une URL spécifiée avec des en-têtes et un corps personnalisables.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - method : Méthode HTTP (GET, POST, PUT, DELETE)
        - url : URL de la requête
        - headers : Dictionnaire des en-têtes HTTP
        - body : Corps de la requête (pour POST et PUT)
        - files : Dictionnaire des fichiers à envoyer (pour POST)
- WebdavAction : Effectue des opérations WebDAV (telles que la création, la lecture, la mise à jour et la suppression de fichiers) sur un serveur WebDAV spécifié.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - method : Méthode WebDAV (GET, PUT, DELETE, MKCOL)
        - url : URL de la requête
        - headers : Dictionnaire des en-têtes HTTP
        - body : Corps de la requête (pour PUT)
        - files : Dictionnaire des fichiers à envoyer (pour PUT)
        - username : Nom d'utilisateur pour l'authentification
        - password : Mot de passe pour l'authentification
- FTPAction : Effectue des opérations FTP (telles que la connexion, le téléchargement et le téléversement de fichiers) sur un serveur FTP spécifié.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - method : Méthode FTP (GET, PUT, DELETE)
        - url : URL de la requête
        - headers : Dictionnaire des en-têtes HTTP
        - body : Corps de la requête (pour PUT)
        - files : Dictionnaire des fichiers à envoyer (pour PUT)
        - username : Nom d'utilisateur pour l'authentification
        - password : Mot de passe pour l'authentification
- SFTPAction : Effectue des opérations SFTP (telles que la connexion, le téléchargement et le téléversement de fichiers) sur un serveur SFTP spécifié.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - method : Méthode SFTP (GET, PUT, DELETE)
        - url : URL de la requête
        - headers : Dictionnaire des en-têtes HTTP
        - body : Corps de la requête (pour PUT)
        - files : Dictionnaire des fichiers à envoyer (pour PUT)
        - username : Nom d'utilisateur pour l'authentification
        - password : Mot de passe pour l'authentification
- SSHAction : Exécute des commandes SSH sur un serveur distant spécifié.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - host : Adresse du serveur SSH
        - port : Port du serveur SSH
        - username : Nom d'utilisateur pour l'authentification
        - password : Mot de passe pour l'authentification
        - command : Commande à exécuter sur le serveur distant
Dans le bandeau du bas, l'application affiche :
- La version de l'application
- Un lien vers le swagger de l'API

Stack technologique utilisé :
- Flask pour le frontend/API
- MongoDB pour la base de données
- JWT pour l'authentification
- Jinja2 pour le templating
- Flask-Swagger pour la documentation de l'API
- Bootstrap pour le design frontend
- FontAwesome pour les icônes
- PyMongo pour l'interaction avec MongoDB
- Tous les fichiers statiques (CSS, JS, images) sont dans le répertoire "static" et téléchargés en local via des CDN
- s'appuie sur requirements.txt pour la gestion des dépendances python

Un fichier de configuration "configuration.json" est utilisé pour définir les paramètres suivants :
- données de connexion à la base de données MongoDB
    => sous la forme :
    "mongo": {
        "user": "root",
        "pass": "mypass",
        "host": "localhost",
        "port": "27017",
        "bdd": "testGyver",
    }
- secret key pour JWT
- paramètres de l'application (port, debug mode, etc.)
- paramètres de pagination (nombre d'éléments par page, etc.)
- paramètres de sécurité (durée d'expiration des tokens, etc.)
- version de l'application

concernant le style et le design :
- utilise un trombone CSS personnalisé dans "static/css/custom.css" sur la page d'authentification
- expose le trombone également sur toutes les pages de l'application pour une cohérence visuelle

Génére un fichier de lancement en mode débug pour visual studio code : .vscode/launch.json

Créer un fichier Dockerfile pour conteneuriser l'application avec un fichier start.sh pour lancer l'application dans le conteneur.
Créer un fichier .gitignore pour ignorer les fichiers et répertoires suivants :
- __pycache__/
- *.pyc
- .env

Renseigne le fichier README.md avec les instructions d'installation et d'utilisation de l'application.
Avec une premiere section pour selectionner la langue souhaitée  (français par défaut).
Avec des fichiers d'autres langues :
- README.en.md
- README.es.md
- README.de.md
- README.it.md



-----------------------

✅ TERMINÉ - traiter les token invalides ou expirés en redirigeant l'utilisateur vers la page de login avec un message d'erreur approprié

Implémentation réalisée :
- Modification de la fonction `decode_token()` pour retourner des messages d'erreur détaillés
- Amélioration du décorateur `token_required` pour différencier les requêtes API et web
- Redirection automatique vers la page de login avec messages flash pour les pages web
- Réponses JSON avec code 401 pour les API
- Suppression automatique des cookies invalides
- Gestion côté client (JavaScript) avec notifications avant redirection
- Messages d'erreur appropriés selon le type d'erreur (expiré, invalide, manquant)
- Gestion des erreurs d'accès administrateur avec redirection vers le dashboard
- Documentation complète : docs/TOKEN_MANAGEMENT.md
- Script de test : test_token_validation.py (tous les tests passent ✅)

faire le menage :
- supprimer les fichiers inutiles
- recherche les consoles.log inutiles et les supprimer


mettre en place un mecanisme multi-langue pour l'interface utilisateur :
- utiliser Flask-Babel pour la gestion des traductions
- créer des fichiers de traduction pour les langues suivantes :
    - français (fr)
    - anglais (en)
    - espagnol (es)
    - allemand (de)
    - italien (it)
- ajouter un sélecteur de langue dans le bandeau supérieur de l'application
- stocker la langue préférée de l'utilisateur dans le profil utilisateur en base de données

complete le swagger avec toutes les routes et modèles de l'API

supprimer une variable racine, supprime egalement toutes les variables associées à cette racine

✅ TERMINÉ - revoir le systeme des plugins d'actions pour permettre l'ajout dynamique de nouvelles actions sans modification du code principal de l'application
✅ TERMINÉ - il y aura d'autre type de plugins à l'avenir (ex: plugins de rapports, plugins d'authentification, etc.)

Architecture mise en place :
- PluginManager : Gestionnaire générique pour tous les types de plugins
- PluginBase : Classe de base commune à tous les plugins
- ActionBase, ReportBase, AuthBase : Classes de base spécialisées
- Découverte et chargement automatique des plugins
- API REST pour gérer les plugins dynamiquement
- Exemples de plugins : HTML Report, Local Auth
- Documentation complète (PLUGIN_DEVELOPMENT_GUIDE.md, PLUGINS_README.md)
- Tests unitaires (test_plugins.py)


-----------------------
✅ TERMINÉ - pour les actions des tests :
- dans les page d'ajout et de modification,
- juste avant le bouton "Ajouter une action",
- ajouter un bouton "Ajouter une variable",
- lors du click sur ce bouton,
- afficher une modale avec un formulaire d'ajout de variable, uniquement le nom,
- la validation est possible, si la variable n'existe pas déjà, et la saisie alphanumérique uniquement
- la liste des variables (si il y a déjà des variables) s'affiche juste avec "actionsList" dans le même parent,
- les variables sont affichées sous la format de tag avec une croix pour la suppression,
- mettre a jour la collections "tests" en conséquence, pour ajouter un champ "variables" qui est un tableau des variables associées au test
- étudier les impacts sur l'existant pour s'assurer que tout fonctionne correctement avec cette nouvelle fonctionnalité

Implémentation réalisée :
- Ajout du champ "variables" (Array) dans la collection "tests"
- Modification du modèle Test pour supporter les variables
- Modification des routes API pour gérer les variables
- Ajout du bouton "Ajouter une variable" dans test_add.html et test_edit.html
- Création de modales pour l'ajout de variables avec validation alphanumérique
- Affichage des variables sous forme de badges avec bouton de suppression
- Validation d'unicité et de format des noms de variables
- Persistance en base de données
- Documentation complète : docs/VARIABLES_TEST_README.md
- Compatibilité totale avec l'existant (tests sans variables fonctionnent normalement)

-----------------------
✅ TERMINÉ - Revoir le systeme de plugins des actions pour permettre aux actions d'alimenter ou non une variable de sortie.
- Chaque action pourra définir une ou plusieurs variables de sortie
- Ces variables pourront être utilisées dans les actions suivantes du même test
- Mettre à jour la documentation des plugins d'actions pour expliquer comment définir des variables de sortie
- Mettre à jour l'interface utilisateur pour afficher les variables de sortie disponibles lors de la configuration des actions dans un test
- ce mécanisme s'appuiera sur la méthode "get_output_variables()" de chaque action pour récupérer la liste des variables de sortie définies par l'action, cette méthode la liste des variables de sortie possibles => qui sera câblée aux potentiels variables du test
- mettre à jour l'interface d'ajout et de modification d'un test

----------------------------------------------
✅ TERMINÉ -sur les pages d'ajout et de modification d'un test,
- dans la liste des actions du test,
- pour chaque action,
- afficher la liste des variables de sortie utilisées par cette action (si il y en a),
- dans le même parent que "<h6 class="mb-0">Action </h6>" et à la suite, aligné à droite,
- afficher les variables de sortie sous forme de badge avec le nom de la variable,
- mettre une couleur "success" pour les badges des variables de sortie (si la variable est bien définie dans l'action),
- si la variable de sortie n'est pas définie dans l'action, mettre une couleur "secondary" pour le badge,
- mettre à jour les fichiers templates/test_add.html et templates/test_edit.html en conséquence

----------------------------------------------
✅ TERMINÉ -lors de la saisie du nom d'une variable dans les actions d'un test, ne pas activer le plugin JS de suggestion des variables existantes variable-autocomplete.js


----------------------------------------------
✅ TERMINÉ - faire évoluer le plugin JS de suggestion des variables existantes variable-autocomplete.js pour permettre de créer plusieurs type de suggestions :
- type "testGyver" : suggère les variables existantes (comportement actuel avec coloration actuelle)
- type "test" : suggère les variables du test en cours
- type "collection" : suggère les variables de collection (test_id, campain_id)
- chaque type de suggestion doit etre dans une liste, avoir une couleur spécifique, et un format d'affichage en majuscule et un format d'insertion spécifique
    - par exemple:
        - type "testGyver" : couleur bleue, format d'insertion {{variable_name}}
        - type "test" : couleur verte, format d'insertion {{app.variable_name}}
        - type "collection" : couleur rouge, format d'insertion {{test.variable_name}}
- faire évoluer les pages test_add.html et test_edit.html pour, lors de la saisie des paramètre d'une action, alimenter le plugin JS avec les deux types de suggestions

Implémentation réalisée :
- Refactorisation du plugin variable-autocomplete.js pour supporter plusieurs types de suggestions
- Configuration des types avec couleurs, icônes et formats d'insertion distincts
- Type "testGyver" : bleu (#0d6efd), format {{variable_name}}, icône fa-database
- Type "test" : vert (#198754), format {{app.variable_name}}, icône fa-vial
- Type "collection" : rouge (#dc3545), format {{test.variable_name}}, icône fa-layer-group
  - Variables de collection disponibles par défaut : test_id, campain_id
- Affichage groupé des suggestions par type avec séparateurs visuels
- Méthode setVariables() pour définir dynamiquement les variables d'un type
- Mise à jour automatique des suggestions dans test_add.html et test_edit.html
- Styles CSS adaptés pour les groupes de suggestions colorées
- Navigation au clavier fluide entre tous les types
- Documentation complète : docs/VARIABLE_AUTOCOMPLETE_MULTITYPE.md
- Page de test : static/test-multitype-autocomplete.html

----------------------------------------------


----------------------------------------------


----------------------------------------------
