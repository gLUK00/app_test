Ce projet est une application de test d'applications web multi-environnements, conçue pour démontrer les capacités de diverses technologies web.

Le nom de l'application "TestGyver" est un jeu de mots entre "Test" et "MacGyver", suggérant une approche ingénieuse et polyvalente pour la réalisation de tests.

L'application expose les pages et API suivantes :
- / : Page d'authentification
- /dashboard : Tableau de bord principal après authentification
    => Affiche la liste des campagnes
    => Pour les administrateurs, affiche dans le bandeau la possibilite de :
        - Gérer les variables multi-environnements
        - Gérer les utilisateurs
    => Bouton d'ajout de campagne
- /campains/add : Ajout d'une nouvelle campagne
- /campains/:id : Détails d'une campagne spécifique
- /campains/:id/add/test : Ajout d'un test à une campagne
    => Formulaire pour ajouter des actions au test
    => Le formulaire correspond au masque de saisie des actions
- /admin/users : Gestion des utilisateurs (accessible uniquement aux administrateurs)
    - /admin/users/add : Ajout d'un nouvel utilisateur
    - /admin/users/edit/:id : Édition d'un utilisateur existant
- /admin/variables : Gestion des variables (accessible uniquement aux administrateurs)
    => Affiche la liste des variables
    => Bouton d'ajout de variable
    => Trier les variables par environnement
    => Regrouper l'affichage des variables par environnement
    - /admin/variables/add : Ajout d'une nouvelle variable
    - /admin/variables/edit/:id : Édition d'une variable existante
- /api/login : API d'authentification
    => Retourne un token JWT en cas de succès
- /api/logout : API de déconnexion
- /api/users : API de gestion des utilisateurs
    - GET /api/users : Récupère la liste des utilisateurs (admin uniquement)
    - POST /api/users : Crée un nouvel utilisateur (admin uniquement)
    - PUT /api/users/:id : Met à jour un utilisateur existant (admin uniquement)
    - DELETE /api/users/:id : Supprime un utilisateur (admin uniquement)
- /api/campains : API de gestion des campagnes
    - GET /api/campains : Récupère la liste des campagnes
    - POST /api/campains : Crée une nouvelle campagne
    - GET /api/campains/:id : Récupère les détails d'une campagne spécifique
    - PUT /api/campains/:id : Met à jour une campagne existante
    - DELETE /api/campains/:id : Supprime une campagne
- /api/variables : API de gestion des variables (accessible uniquement aux administrateurs)
    - GET /api/variables : Récupère la liste des variables
    - POST /api/variables : Crée une nouvelle variable
    - GET /api/variables/:id : Récupère les détails d'une variable spécifique
    - PUT /api/variables/:id : Met à jour une variable existante
    - DELETE /api/variables/:id : Supprime une variable
- /api/tests : API de gestion des tests
    - GET /api/tests : Récupère la liste des tests
    - POST /api/tests : Crée un nouveau test
    - GET /api/tests/:id : Récupère les détails d'un test spécifique
    - PUT /api/tests/:id : Met à jour un test existant
    - DELETE /api/tests/:id : Supprime un test
- /api/rapports : API de génération et récupération des rapports
    - GET /api/rapports : Récupère la liste des rapports
    - POST /api/rapports : Crée un nouveau rapport
    - GET /api/rapports/:id : Récupère les détails d'un rapport spécifique
    - PUT /api/rapports/:id : Met à jour un rapport existant
    - DELETE /api/rapports/:id : Supprime un rapport
- /swagger : Documentation interactive de l'API

L'application s'appuie sur une base de données mongo et les collections suivantes :
- users
    - _id: ObjectId
    - name: String
    - email: String
    - password: String (hashed)
    - role: String (admin, user)
- variables
    - _id: ObjectId
    - key: String
    - value: Mixed
    - filiere: String
    - description: String
    - isRoot: Boolean (default: false), determine si la variable fait partie du masquage racine
- campains
    - _id: ObjectId
    - userCreated: ObjectId (référence à users)
    - name: String
    - dateCreated: Date
    - description: String
- tests
    - _id: ObjectId
    - campainId: ObjectId (référence à campains)
    - userId: ObjectId (référence à users)
    - dateCreated: Date
    - actions: Array of Objects
        - type: String (spécificité de l'action en fonction des classes d'actions)
        - value: Mixed
- rapports
    - _id: ObjectId
    - campainId: ObjectId (référence à campains)
    - dateCreated: Date
    - result: String (success, failure)
    - details: String
    - filiere: String
    - tests: Array of Objects
        - testId: ObjectId (référence à tests)
        - status: String (passed, failed)
        - logs: String

Les classes d'actions :
- disponible dans le répertoire "plugins/actions"
- chaque classe d'action hérite de la classe de base "ActionBase" qui retourne un code et des traces d'exécution
- chaque action à un masque de saisie spécifique pour les paramètres nécessaires à l'exécution de l'action
    => représenté par un dictionnaire JSON sous la forme :
    {
        "name": "username",
        "type": "string",
        "label": "Nom d'utilisateur",
        "placeholder": "Entrez le nom d'utilisateur",
        "required": true
    }
    => les différents types de champs disponibles sont :
        - string
        - number
        - boolean
        - textarea
        - select (avec une liste d'options)
        - checkbox (case à cocher)
- lors de la saisie d'une champs de type "string" ou "textarea", en fonction du mot en cours de saisie, une liste de tags de variables est proposée à l'utilisateur pour l'insertion
    => si l'utilisateur click sur un tag, celui-ci est inséré dans le champs de saisie par {{variable_key}}
- chaque classe d'action doit implémenter la méthode "execute" qui prend en paramètre un objet de type "ActionContext" qui contient les informations nécessaires à l'exécution de l'action (spécifiques à chaque action )

Les actions disponibles sont :
- HTTPRequestAction : Effectue une requête HTTP (GET, POST, PUT, DELETE) vers une URL spécifiée avec des en-têtes et un corps personnalisables.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - method : Méthode HTTP (GET, POST, PUT, DELETE)
        - url : URL de la requête
        - headers : Dictionnaire des en-têtes HTTP
        - body : Corps de la requête (pour POST et PUT)
        - files : Dictionnaire des fichiers à envoyer (pour POST)
- WebdavAction : Effectue des opérations WebDAV (telles que la création, la lecture, la mise à jour et la suppression de fichiers) sur un serveur WebDAV spécifié.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - method : Méthode WebDAV (GET, PUT, DELETE, MKCOL)
        - url : URL de la requête
        - headers : Dictionnaire des en-têtes HTTP
        - body : Corps de la requête (pour PUT)
        - files : Dictionnaire des fichiers à envoyer (pour PUT)
        - username : Nom d'utilisateur pour l'authentification
        - password : Mot de passe pour l'authentification
- FTPAction : Effectue des opérations FTP (telles que la connexion, le téléchargement et le téléversement de fichiers) sur un serveur FTP spécifié.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - method : Méthode FTP (GET, PUT, DELETE)
        - url : URL de la requête
        - headers : Dictionnaire des en-têtes HTTP
        - body : Corps de la requête (pour PUT)
        - files : Dictionnaire des fichiers à envoyer (pour PUT)
        - username : Nom d'utilisateur pour l'authentification
        - password : Mot de passe pour l'authentification
- SFTPAction : Effectue des opérations SFTP (telles que la connexion, le téléchargement et le téléversement de fichiers) sur un serveur SFTP spécifié.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - method : Méthode SFTP (GET, PUT, DELETE)
        - url : URL de la requête
        - headers : Dictionnaire des en-têtes HTTP
        - body : Corps de la requête (pour PUT)
        - files : Dictionnaire des fichiers à envoyer (pour PUT)
        - username : Nom d'utilisateur pour l'authentification
        - password : Mot de passe pour l'authentification
- SSHAction : Exécute des commandes SSH sur un serveur distant spécifié.
    => le dictionnaire transmis dans "value" doit contenir les clés suivantes :
        - host : Adresse du serveur SSH
        - port : Port du serveur SSH
        - username : Nom d'utilisateur pour l'authentification
        - password : Mot de passe pour l'authentification
        - command : Commande à exécuter sur le serveur distant
Dans le bandeau du bas, l'application affiche :
- La version de l'application
- Un lien vers le swagger de l'API

Stack technologique utilisé :
- Flask pour le frontend/API
- MongoDB pour la base de données
- JWT pour l'authentification
- Jinja2 pour le templating
- Flask-Swagger pour la documentation de l'API
- Bootstrap pour le design frontend
- FontAwesome pour les icônes
- PyMongo pour l'interaction avec MongoDB
- Tous les fichiers statiques (CSS, JS, images) sont dans le répertoire "static" et téléchargés en local via des CDN
- s'appuie sur requirements.txt pour la gestion des dépendances python

Un fichier de configuration "configuration.json" est utilisé pour définir les paramètres suivants :
- données de connexion à la base de données MongoDB
    => sous la forme :
    "mongo": {
        "user": "root",
        "pass": "mypass",
        "host": "localhost",
        "port": "27017",
        "bdd": "testGyver",
    }
- secret key pour JWT
- paramètres de l'application (port, debug mode, etc.)
- paramètres de pagination (nombre d'éléments par page, etc.)
- paramètres de sécurité (durée d'expiration des tokens, etc.)
- version de l'application

concernant le style et le design :
- utilise un trombone CSS personnalisé dans "static/css/custom.css" sur la page d'authentification
- expose le trombone également sur toutes les pages de l'application pour une cohérence visuelle

Génére un fichier de lancement en mode débug pour visual studio code : .vscode/launch.json

Créer un fichier Dockerfile pour conteneuriser l'application avec un fichier start.sh pour lancer l'application dans le conteneur.
Créer un fichier .gitignore pour ignorer les fichiers et répertoires suivants :
- __pycache__/
- *.pyc
- .env

Renseigne le fichier README.md avec les instructions d'installation et d'utilisation de l'application.
Avec une premiere section pour selectionner la langue souhaitée  (français par défaut).
Avec des fichiers d'autres langues :
- README.en.md
- README.es.md
- README.de.md
- README.it.md



-----------------------

✅ TERMINÉ - traiter les token invalides ou expirés en redirigeant l'utilisateur vers la page de login avec un message d'erreur approprié

Implémentation réalisée :
- Modification de la fonction `decode_token()` pour retourner des messages d'erreur détaillés
- Amélioration du décorateur `token_required` pour différencier les requêtes API et web
- Redirection automatique vers la page de login avec messages flash pour les pages web
- Réponses JSON avec code 401 pour les API
- Suppression automatique des cookies invalides
- Gestion côté client (JavaScript) avec notifications avant redirection
- Messages d'erreur appropriés selon le type d'erreur (expiré, invalide, manquant)
- Gestion des erreurs d'accès administrateur avec redirection vers le dashboard
- Documentation complète : docs/TOKEN_MANAGEMENT.md
- Script de test : test_token_validation.py (tous les tests passent ✅)

faire le menage :
- supprimer les fichiers inutiles
- recherche les consoles.log inutiles et les supprimer


mettre en place un mecanisme multi-langue pour l'interface utilisateur :
- utiliser Flask-Babel pour la gestion des traductions
- créer des fichiers de traduction pour les langues suivantes :
    - français (fr)
    - anglais (en)
    - espagnol (es)
    - allemand (de)
    - italien (it)
- ajouter un sélecteur de langue dans le bandeau supérieur de l'application
- stocker la langue préférée de l'utilisateur dans le profil utilisateur en base de données

complete le swagger avec toutes les routes et modèles de l'API

supprimer une variable racine, supprime egalement toutes les variables associées à cette racine

construire une image docker officielle de l'application et la publier sur Docker Hub


-----------------------



✅ TERMINÉ - revoir le systeme des plugins d'actions pour permettre l'ajout dynamique de nouvelles actions sans modification du code principal de l'application
✅ TERMINÉ - il y aura d'autre type de plugins à l'avenir (ex: plugins de rapports, plugins d'authentification, etc.)

Architecture mise en place :
- PluginManager : Gestionnaire générique pour tous les types de plugins
- PluginBase : Classe de base commune à tous les plugins
- ActionBase, ReportBase, AuthBase : Classes de base spécialisées
- Découverte et chargement automatique des plugins
- API REST pour gérer les plugins dynamiquement
- Exemples de plugins : HTML Report, Local Auth
- Documentation complète (PLUGIN_DEVELOPMENT_GUIDE.md, PLUGINS_README.md)
- Tests unitaires (test_plugins.py)


-----------------------
✅ TERMINÉ - pour les actions des tests :
- dans les page d'ajout et de modification,
- juste avant le bouton "Ajouter une action",
- ajouter un bouton "Ajouter une variable",
- lors du click sur ce bouton,
- afficher une modale avec un formulaire d'ajout de variable, uniquement le nom,
- la validation est possible, si la variable n'existe pas déjà, et la saisie alphanumérique uniquement
- la liste des variables (si il y a déjà des variables) s'affiche juste avec "actionsList" dans le même parent,
- les variables sont affichées sous la format de tag avec une croix pour la suppression,
- mettre a jour la collections "tests" en conséquence, pour ajouter un champ "variables" qui est un tableau des variables associées au test
- étudier les impacts sur l'existant pour s'assurer que tout fonctionne correctement avec cette nouvelle fonctionnalité

Implémentation réalisée :
- Ajout du champ "variables" (Array) dans la collection "tests"
- Modification du modèle Test pour supporter les variables
- Modification des routes API pour gérer les variables
- Ajout du bouton "Ajouter une variable" dans test_add.html et test_edit.html
- Création de modales pour l'ajout de variables avec validation alphanumérique
- Affichage des variables sous forme de badges avec bouton de suppression
- Validation d'unicité et de format des noms de variables
- Persistance en base de données
- Documentation complète : docs/VARIABLES_TEST_README.md
- Compatibilité totale avec l'existant (tests sans variables fonctionnent normalement)

-----------------------
✅ TERMINÉ - Revoir le systeme de plugins des actions pour permettre aux actions d'alimenter ou non une variable de sortie.
- Chaque action pourra définir une ou plusieurs variables de sortie
- Ces variables pourront être utilisées dans les actions suivantes du même test
- Mettre à jour la documentation des plugins d'actions pour expliquer comment définir des variables de sortie
- Mettre à jour l'interface utilisateur pour afficher les variables de sortie disponibles lors de la configuration des actions dans un test
- ce mécanisme s'appuiera sur la méthode "get_output_variables()" de chaque action pour récupérer la liste des variables de sortie définies par l'action, cette méthode la liste des variables de sortie possibles => qui sera câblée aux potentiels variables du test
- mettre à jour l'interface d'ajout et de modification d'un test

----------------------------------------------
✅ TERMINÉ -sur les pages d'ajout et de modification d'un test,
- dans la liste des actions du test,
- pour chaque action,
- afficher la liste des variables de sortie utilisées par cette action (si il y en a),
- dans le même parent que "<h6 class="mb-0">Action </h6>" et à la suite, aligné à droite,
- afficher les variables de sortie sous forme de badge avec le nom de la variable,
- mettre une couleur "success" pour les badges des variables de sortie (si la variable est bien définie dans l'action),
- si la variable de sortie n'est pas définie dans l'action, mettre une couleur "secondary" pour le badge,
- mettre à jour les fichiers templates/test_add.html et templates/test_edit.html en conséquence

----------------------------------------------
✅ TERMINÉ -lors de la saisie du nom d'une variable dans les actions d'un test, ne pas activer le plugin JS de suggestion des variables existantes variable-autocomplete.js


----------------------------------------------
✅ TERMINÉ - faire évoluer le plugin JS de suggestion des variables existantes variable-autocomplete.js pour permettre de créer plusieurs type de suggestions :
- type "testGyver" : suggère les variables existantes (comportement actuel avec coloration actuelle)
- type "test" : suggère les variables du test en cours
- type "collection" : suggère les variables de collection (test_id, campain_id)
- chaque type de suggestion doit etre dans une liste, avoir une couleur spécifique, et un format d'affichage en majuscule et un format d'insertion spécifique
    - par exemple:
        - type "testGyver" : couleur bleue, format d'insertion {{variable_name}}
        - type "test" : couleur verte, format d'insertion {{app.variable_name}}
        - type "collection" : couleur rouge, format d'insertion {{test.variable_name}}
- faire évoluer les pages test_add.html et test_edit.html pour, lors de la saisie des paramètre d'une action, alimenter le plugin JS avec les deux types de suggestions

Implémentation réalisée :
- Refactorisation du plugin variable-autocomplete.js pour supporter plusieurs types de suggestions
- Configuration des types avec couleurs, icônes et formats d'insertion distincts
- Type "testGyver" : bleu (#0d6efd), format {{variable_name}}, icône fa-database
- Type "test" : vert (#198754), format {{app.variable_name}}, icône fa-vial
- Type "collection" : rouge (#dc3545), format {{test.variable_name}}, icône fa-layer-group
  - Variables de collection disponibles par défaut : test_id, campain_id
- Affichage groupé des suggestions par type avec séparateurs visuels
- Méthode setVariables() pour définir dynamiquement les variables d'un type
- Mise à jour automatique des suggestions dans test_add.html et test_edit.html
- Styles CSS adaptés pour les groupes de suggestions colorées
- Navigation au clavier fluide entre tous les types
- Documentation complète : docs/VARIABLE_AUTOCOMPLETE_MULTITYPE.md
- Page de test : static/test-multitype-autocomplete.html

----------------------------------------------
✅ TERMINÉ - ajouter la collection (en rouge), contenant "TEST_ID" et "CAMPAIN_ID" qui seront remplacés pas {{test.test_id}} ou {{test.campain_id}}

----------------------------------------------

----------------------------------------------
✅ TERMINÉ - lors de la demande d'execution d'une campagne :
- afficher un formulaire,
    - avec le nom de la campagne, par default contiendra le mois et l'année en cours ex : Mars 2023, si le nom existe déjà, ajouter un suffixe numérique pour le rendre unique ex : Mars 2023 (1),
    - avec le choix de l'environnement (liste des filieres existantes dans les variables)
    - avec les choix de la stratégie d'execution pour determiner si les tests doivents etre arretés au premier échec ou continuer jusqu'au bout (case à cocher)
    - avec les boutons "Lancer la campagne" et "Annuler"
    - le nom de la campagne est obligatoire et doit etre unique
le lancement de la campagne executera un nouveau processus en arriere plan, les données d'execution de la campagne seront raffraichies vie un websocket d'écoute
utilise Flask-SocketIO pour la gestion des websockets
affiche dans la liste des rapports, le statut d'execution de la campagne (en cours, terminé, échoué) avec un % de progression
lors du click sur une campagne en cours, affiche une page de détails avec la liste des tests et leur statut d'execution (en attente, en cours, réussi, échoué) avec les logs d'execution en temps réel via websocket

Implémentation réalisée :
- Installation et configuration de Flask-SocketIO avec eventlet
- Extension du modèle Rapport avec status, progress, stopOnFailure
- Module CampainExecutor pour l'exécution en arrière-plan
- Modale de lancement avec nom auto-généré et validation d'unicité
- API REST : /api/rapports/execute, /api/rapports/generate-name, /api/rapports/filieres
- Événements WebSocket : campain_started, test_started, test_completed, campain_progress, campain_completed, campain_error
- Page campain_details.html mise à jour avec liste des rapports et statuts
- Nouvelle page rapport_details.html avec suivi en temps réel
- Résolution complète des variables (TestGyver, test, collection)
- Tests unitaires : _build/test_campain_execution.py
- Documentation : docs/CAMPAIN_EXECUTION_README.md, docs/IMPLEMENTATION_CAMPAIN_EXECUTION.md

----------------------------------------------
✅ TERMINÉ - sur le formulaire de lancement de campagne, la liste des environnements ne doit contenir que les filières distinctes des variables existantes (pas de variables racines n'y vides)

Implémentation réalisée :
- Modification de la méthode `get_all_filieres()` dans le modèle Variable
- Utilisation d'un pipeline d'agrégation MongoDB pour filtrer :
  - Exclusion des variables racines (isRoot = true)
  - Exclusion des filières vides, null ou inexistantes
  - Tri alphabétique des filières
- La route `/api/rapports/filieres` retourne maintenant uniquement les filières valides

----------------------------------------------

créer moi une image de macgyver en mode pixel art en png avec un fond transparent
créer un logo sur la page d'acceuil avec le slogant "Really, are you serious ?"
illustrant l'esprit ingénieux et débrouillard de MacGyver, tout en ajoutant une touche d'humour avec le slogan.
en mettant en avant le pixel art et le trombone

----------------------------------------------

✅ TERMINÉ - recherche si il y a des cdn utilisés dans les fichiers templates/*.html et les remplacer par des fichiers locaux dans static/ (css, js, images, etc.)

Implémentation réalisée :
- Téléchargement de Bootstrap 5.3.0 (CSS + JS)
- Téléchargement de Font Awesome 6.4.0 (CSS + polices webfonts)
- Téléchargement de Socket.IO 4.5.4 (JS)
- Organisation dans static/vendor/ avec structure claire
- Mise à jour de tous les templates (base.html, login.html, rapport_details.html)
- Mise à jour des fichiers de test (test-autocomplete.html, test-multitype-autocomplete.html)
- Correction des chemins des polices Font Awesome
- Documentation complète : docs/CDN_TO_LOCAL_MIGRATION.md
- Taille totale : ~729 KB
- 7 requêtes HTTP externes éliminées
- Amélioration de la performance, sécurité et confidentialité

----------------------------------------------

✅ TERMINÉ - le bouton retour de la page du détail d'un rapport conduit à la liste des campagnes, il doit conduire à la liste des rapports

Implémentation réalisée :
- Modification de la route `rapport_details` dans `routes/web_routes.py`
- Récupération du `campain_id` depuis le rapport
- Passage du `campain_id` au template
- Mise à jour du template `rapport_details.html`
- Le bouton retour redirige maintenant vers `url_for('web.campain_details', campain_id=campain_id)`
- Fallback vers le dashboard si le campain_id n'est pas disponible

----------------------------------------------


creer un plugin d'action "IoAction" pour effectuer :
- création de répertoire,
- suppression de répertoire,
- suppression de fichier,
- écriture d'une variable dans un fichier,
- alimentation d'une variable depuis un fichier,
- récupère une liste de fichiers dans un répertoire avec possibilité de filtrer par extension

----------------------------------------------


✅ TERMINÉ - creer une entrée dans le fichier de configuration.json pour définir le répertoire de travail des campagnes "workdir".
- lors de la création d'une campagne, créer un répertoire dans ce workdir avec l'id de la campagne
- lors de la suppression d'une campagne, supprimer le répertoire correspondant dans le workdir
- lors du démarrage de l'application, vérifier que le répertoire workdir existe, sinon le créer et supprimer les répertoires orphelins

Implémentation réalisée :
- Ajout de l'entrée "workdir": "./workdir" dans configuration.json
- Création du module utils/workdir.py avec les fonctions :
  - get_workdir() : récupère le chemin du workdir depuis la config
  - ensure_workdir_exists() : vérifie et crée le workdir, supprime les orphelins
  - create_campain_workdir(campain_id) : crée le répertoire d'une campagne
  - delete_campain_workdir(campain_id) : supprime le répertoire d'une campagne
  - get_campain_workdir(campain_id) : récupère le chemin du répertoire
- Modification de app.py pour initialiser le workdir au démarrage
- Modification de routes/campains_routes.py :
  - Création du répertoire lors de la création d'une campagne
  - Suppression du répertoire lors de la suppression d'une campagne
- Ajout de workdir/ au .gitignore
- Script de test : _build/test_workdir_management.py
- ⚠️ Note : Utilisation systématique de python3 au lieu de python

----------------------------------------------


✅ TERMINÉ - dans la gestion d'une campagne, ajouter une section "Fichiers" entre "informations" et "Tests de la campagne"
- cette section liste les fichiers présents dans le répertoire de travail de la campagne
- avec un bouton "Télécharger" pour chaque fichier
- avec un bouton "Supprimer" pour chaque fichier
- avec un bouton "Ajouter un fichier" qui ouvre une modale pour uploader un fichier dans le répertoire de travail de la campagne,
    - le formulaire d'upload doit contenir un champ de sélection de fichier et un bouton "Uploader"
    - un champ de saisie pour renommer le fichier avant l'upload (optionnel)
- gérer les routes API nécessaires pour l'upload,
    le téléchargement et la suppression des fichiers dans le répertoire de travail de la campagne
- la liste des fichiers doit se raffraichir automatiquement après chaque opération (upload, suppression) via websocket
- la liste affiche le nom du fichier, sa taille (en Ko) et sa date de dernière modification

Implémentation réalisée :
- Ajout des routes API dans routes/campains_routes.py :
  - GET /api/campains/:id/files : Liste les fichiers
  - POST /api/campains/:id/files : Upload un fichier (avec option de renommage)
  - GET /api/campains/:id/files/:filename : Télécharge un fichier
  - DELETE /api/campains/:id/files/:filename : Supprime un fichier
  - Émission d'événements WebSocket files_updated après upload/suppression
- Modification de templates/campain_details.html :
  - Ajout de la section "Fichiers" entre Informations et Tests
  - Tableau avec nom, taille (Ko), date de modification et boutons d'action
  - Modale d'upload avec sélection de fichier et champ de renommage optionnel
  - JavaScript pour CRUD complet et écoute WebSocket
- Modification de app.py :
  - Ajout des gestionnaires join/leave pour les rooms WebSocket
- Sécurité :
  - Utilisation de secure_filename() pour sécuriser les noms de fichiers
  - Vérification d'existence de la campagne pour toutes les opérations
  - Token JWT requis pour toutes les routes
- Rafraîchissement automatique via WebSocket dans la room campain_{campain_id}
- Documentation complète : 
  - docs/FILES_MANAGEMENT.md (documentation détaillée)
  - docs/FILES_MANAGEMENT_SUMMARY.md (résumé de l'implémentation)
  - docs/FILES_MANAGEMENT_QUICKSTART.md (guide de test rapide)
- Script de test : _build/test_files_management.py

----------------------------------------------

creer un plugin d'action "IoAction" pour effectuer :
- création de répertoire,
- suppression de répertoire,
- suppression de fichier,
- écriture d'une variable dans un fichier,
- alimentation d'une variable depuis un fichier,
- récupère une liste de fichiers dans un répertoire avec possibilité de filtrer par extension

----------------------------------------------

mettre en place un mecanisme multi-langue pour l'interface utilisateur :
- utiliser Flask-Babel pour la gestion des traductions
- créer des fichiers de traduction pour les langues suivantes :
    - français (fr)
    - anglais (en)
    - espagnol (es)
    - allemand (de)
    - italien (it)
- ajouter un sélecteur de langue dans le bandeau supérieur de l'application
- stocker la langue préférée de l'utilisateur dans le profil utilisateur en base de données

----------------------------------------------

complete le swagger avec toutes les routes et modèles de l'API

----------------------------------------------

supprimer une variable racine, supprime egalement toutes les variables associées à cette racine

----------------------------------------------

construire une image docker officielle de l'application et la publier sur Docker Hub

----------------------------------------------

✅ TERMINÉ - lors de la saisie des variables des actions d'un test,
- ajouter au mécanisme d'autocomplete des variables,
- dans la même section que "test.test_id" et "test.campain_id",
- "test.files_dir" qui correspond au "files" de la campagne,
- "test.work_dir" qui correspond au répertoire de travail de la campagne
- le format d'insertion sera {{test.files_dir}} et {{test.work_dir}}
- messure les impacts sur l'existant et teste que tout fonctionne correctement

Implémentation réalisée :
- Modification de static/js/variable-autocomplete.js :
  - Ajout de files_dir dans initCollectionVariables()
  - Ajout de work_dir dans initCollectionVariables()
  - Descriptions ajoutées pour chaque variable
- Modification de utils/campain_executor.py :
  - Import de get_campain_workdir depuis utils.workdir
  - Import de Path depuis pathlib
  - Calcul des chemins files_dir et work_dir basés sur le campain_id
  - Ajout de test.files_dir dans variables_dict
  - Ajout de test.work_dir dans variables_dict
- Variables de collection disponibles :
  - {{test.test_id}} : ID du test en cours
  - {{test.campain_id}} : ID de la campagne
  - {{test.files_dir}} : Chemin absolu vers workdir/{campain_id}/files
  - {{test.work_dir}} : Chemin absolu vers workdir/{campain_id}/work
- Compatibilité totale avec l'existant (aucun impact négatif)
- Documentation complète : docs/COLLECTION_VARIABLES_FILES_WORK.md
- Script de test : _build/test_collection_variables.py (tous les tests passent ✅)

----------------------------------------------
